# -*- coding: utf-8 -*-
"""Minicurso_Python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ntBADbVHLbFY0587FcUV6bRHdxGLkup_

# Python aplicado ao Cálculo para Engenheiros

O Python é uma linguagem de programação de alto nível, interpretada e de propósito geral. É uma linguagem bastante utilizada em áreas como a ciência de dados, aprendizado de máquina, processamento de sinais e sistemas, entre outras. A linguagem possui uma sintaxe simples e fácil de aprender, além de uma vasta biblioteca padrão e de terceiros, tornando-a bastante versátil.

## 1. Conceitos Básicos

### Apresentando resultados na tela

Para apresentar resultados na tela, utilizamos a função `print()`. Por exemplo, para imprimir a string "Olá, mundo!", basta executar o seguinte comando:
"""

print("Olá, mundo!")

a = 5
print("a = ", a)

"""### Operações com números reais

Para fazer operações com números reais, utilizamos os operadores aritméticos padrão (`+`, `-`, `*`, `/`, `**`). Por exemplo, para calcular a soma, subtração, multiplicação, divisão e potenciação de dois números reais, basta executar o seguinte código:
"""

a = 2.5
b = 3.2

soma = a + b
print("a + b =", soma)

subt = a - b
print("a - b =", subt)

mult = a*b
print("a*b = ", mult)

div = a/b
print("a/b = ", div)

powa = a**2         #a^2
print("a^2 = ", powa)

expr = (a - b)*(a + b)/a**2
print("Expr = ", expr)

"""Para utilizar funções mais complexas, como seno, cosseno, raiz quadrada, entre outras, poderemos importar a biblioteca `numpy`."""

#Importando a numpy
import numpy as np

angle = np.pi/6
x1 = np.cos(angle)
x2 = np.sin(angle)
x3 = np.tan(angle)
x4 = np.sqrt(5)

print("cos(pi/6) = ", x1)
print("sin(pi/6) = ", x2)
print("tan(pi/6) = ", x3)
print("sqrt(5) = ", x4)

"""É importante dizer que o ângulo a ser passado como argumento de uma função trigonométrica deve estar em radianos, necessariamente.

### Estruturas condicionais

As estruturas condicionais permitem executar um bloco de código somente se uma condição for atendida. A estrutura condicional básica do Python é o `if`. Por exemplo, para verificar se um número é positivo, basta executar o seguinte código:
"""

x = -3
if x > 0:
  print("O número é positivo!")

"""Também é possível utilizar a estrutura condicional `else` para executar um bloco de código caso a condição do `if` não seja atendida. Por exemplo:"""

x = 0
if x > 0:
  print("O número é positivo!")
else:
  print("O número é zero ou negativo.")

"""O comando `elif` é utilizado para definir uma condição alternativa. Por exemplo, para verificar se um número é positivo, negativo ou zero, basta executar o seguinte código:"""

x = 0
if x > 0:
  print("O número é positivo!")
elif x < 0:
  print("O número é negativo!")
else:
  print("O número é igual à zero.")

"""### Laços e estruturas de repetição

Os laços permitem executar um bloco de código várias vezes. O laço básico do Python é o `for`. Por exemplo, para imprimir os números de 0 a 4 na tela, basta executar o seguinte código:
"""

for i in range(5): #range(5) = [0 1 2 3 4]
  print(i)

"""Nesse exemplo, o comando `range(5)` cria uma sequência de números de 0 a 4. O laço for percorre essa sequência e a variável `i` assume cada um dos valores. O comando `print(i)` exibe o valor de `i` na tela. O Python permite estrutura de laços que percorrem vários tipos de dados, como, por exemplo, strings:"""

palavra = "Python"
for i in palavra:
  print(i)

"""Também é possível utilizar o laço `while` para executar um bloco de código enquanto uma condição for verdadeira. Por exemplo, para imprimir os números de 0 a 4 na tela utilizando o laço `while`, basta executar o seguinte código:"""

i = 0
while i < 5:
  print(i)
  i = i + 1

"""### Funções

As funções são blocos de código que executam uma tarefa específica e podem ser chamados em outros lugares do programa. Elas permitem que o código seja organizado em módulos lógicos e reutilizáveis. Para criar uma função, usamos a palavra reservada `def`, seguida pelo nome da função, uma lista de parâmetros (se houver) entre parênteses e dois pontos. O bloco de código identado abaixo é executado sempre que a função é chamada.

Por exemplo, para criar uma função que calcula a soma de dois números, podemos usar o seguinte código:
"""

def soma (a, b):
  x = a + b
  print("Resultado = ", x)

"""Para chamar uma função, basta digitar o nome da função, seguido por uma lista de argumentos (se houver) entre parênteses. Por exemplo, para chamar a função `soma` e calcular a soma dos números 2 e 3, basta executar o seguinte código:"""

soma(3, 2)

"""O comando `return` é utilizado para retornar um valor calculado dentro da função. Por exemplo, para criar uma função que retorna a soma de dois números, podemos usar o seguinte código:"""

def soma (a, b):
  x = a + b
  return x

"""Para chamar a função e armazenar o resultado da soma em uma variável, basta executar o seguinte código:"""

y = soma (4, 5)
print("Soma = ", y)

"""### Funções Lambda

A função lambda em Python é usada para criar funções anônimas (ou seja, funções sem nome) de forma concisa. É especialmente útil para funções simples que você deseja usar apenas uma vez. Por exemplo, para criar uma função lambda que adiciona a um número o valor 10, pode-se executar o seguinte código:
"""

adicionar_10 = lambda x: x + 10
y = adicionar_10(5)
print(y)

"""## 2. Vetores e Matrizes

### Criando vetores

Podemos criar vetores e matrizes de diferentes formas no Python, mas neste curso usaremos a bibliotecada `numpy`. A `numpy` é uma biblioteca para Python que permite trabalhar com vetores e matrizes de forma mais eficiente do que com a classe `list` padrão.

Um vetor é uma sequência de valores. Em NumPy, podemos criar um vetor usando a função `array`, como mostrado abaixo:
"""

#Importar a biblioteca numpy
import numpy as np

#Criando vetores em Python usando a Numpy
v1 = np.array([1, 2, 3])
print(v1)

v2 = np.array([-1, 2, -3])
print(v2)

"""Com a função `arange()` é possível gerar um vetor com valores espaçados de acordo com um intervalo e um passo definidos pelo usuário. A sintaxe é a seguinte:

```python
np.arange(start, stop, step)
```

onde:

* `start`: o valor inicial do intervalo (inclusive);
* `stop`: o valor final do intervalo (exclusive);
* `step`: o espaçamento entre os valores.

Por exemplo, vamos criar os seguintes vetores:

a) Vetor iniciando em 0, terminando em 10, com passo 2.

b) Vetor inciando em 0, terminando em 2,5, com passo de 0,5.

c) Vetor incinando em 3, terminando em 0,2, com passo de -0,4.

d) Vetor iniciando em 0, terminando em 9, com passo de 1.
"""

va = np.arange(0, 11, 2) #[0 2 4 6 8 10]
print(va)

inicio = 0
fim = 2.5
passo = 0.5
vb = np.arange(inicio, fim+passo, passo)
print(vb)

inicio = 3
fim = 0.2
passo = -0.4
vc = np.arange(inicio, fim+passo, passo)
print(vc)

inicio = 0
fim = 9
vd = np.arange(inicio, fim+1)
print(vd)

"""A função `linspace` da biblioteca `numPy` é utilizada para criar uma sequência de valores igualmente espaçados dentro de um intervalo especificado. Isso é particularmente útil ao gerar valores para plotagem de gráficos, realizar interpolações ou qualquer outra situação onde seja necessário um conjunto uniformemente espaçado de valores. A sintaxe básica é apresentada abaixo:

```python
np.linspace(start, stop, num_points)
```

onde:

* `start`: o valor inicial do intervalo (inclusive);
* `stop`: o valor final do intervalo (inclusive);
* `num_points`: número de pontos.

Vamos criar um vetor de valores iniciando no 0, terminando no 10 e esse vetor de 21 valores.
"""

import numpy as np

inicio = 0
fim = 10
Npoints = 21
ve = np.linspace(inicio, fim, Npoints)
print(ve)

vf = np.linspace(0, 5, 11)
for i in vf:
  print(i)

"""### Acesso à um vetor

Para acessar os elementos de um vetor, fazemos da mesma forma do C. O indice `-1` sempre indica a última posição de um vetor.
"""

x1 = np.linspace(3,14,11)
print(x1)

print(x1[1])

print(x1[5])

print(x1[-1])

x1[2] = 87
print(x1)

"""### Operações com vetores

Após criado os vetores, podemos realizar várias operações com eles, como soma, multiplicação por escalar, produto interno, produto vetorial, bem como calcular a norma de um vetor.

Vamos supor dois vetores:

$$
\mathbb{v}_1 = [1, 2, 3]
$$

$$
\mathbb{v}_2 = [-1, 2, -3]
$$

Vamos realizar as operações de soma, multiplicação por escalar, produto interno, produto vetorial e a norma desses vetores.
"""

v1 = np.array([1,2,3])
v2 = np.array([-1,2,-3])

print(v1)
print(v2)

vsoma = v1 + v2
print(vsoma)

vmult = 2*v1
print(vmult)

vdot = np.dot(v1, v2)
print(vdot)

vcross = np.cross(v1, v2)
print(vcross)

vnorm = np.linalg.norm(v1)          #Usa a função norm que está no pacote linalg da biblioteca numpy
print(vnorm)

vnorm = np.linalg.norm(v2)
print(vnorm)

"""### Criando Matrizes

Uma matriz é uma tabela de valores. Com a `numpy`, podemos representar uma matriz usando um array multidimensional. Cada dimensão representa uma linha ou uma coluna da matriz.
"""

import numpy as np

A = np.array([[1, 2], [3, 5]])
print(A)

B = np.array([[1, 3, 4], [4, 7, -1]])
print(B)

C = np.array([[2, 0], [1, 3]])
print(C)

"""### Acesso à matrizes

A forma de acesso à elementos de uma matriz é feito de forma semalhante à vetores. Podemos acessar um elemento da matriz usando dois índices: o primeiro para a linha e o segundo para a coluna.
"""

print(A[0][1])

print(B[1][1])

print(B[1][2])

"""Com isso, podemos modificar um certo valor de uma matriz."""

B[1][2] = 10
print(B)

"""### Operações com Matrizes

Assim como vetores, podemos realizar várias operações com matrizes, como soma, multiplicação por escalar, transposição, determinante e a matriz inversa.

Supondo as matrizes definidas anteriormente, vamos realizar as operações de soma, multiplicação por escalar, multiplicação de matrizes, transposição, determinando e inversa de matrizes.
"""

print(A)

print(C)

#Somar duas matrizes
Msoma = A + C
print(Msoma)

#Multiplicar a matriz por um escalar
Mesc = 2*A
print(Mesc)

#Multiplicar duas matrizes
AC = np.dot(A,C)
print(AC)

AB = np.dot(B,A)
print(AB)

#Transposicao
At = A.T
print(At)

#Determinante de um matriz
Adet = np.linalg.det(A)
print(Adet)

Bdet = np.linalg.det(B)

Ainv = np.linalg.inv(A)
print(Ainv)

T = np.dot(A,Ainv)
print(T)

"""### Sistemas de Equações

Utilizando funções da `numpy` é possível solucionar um sistema de equações. Suponha que desejamos solucionar o seguinte sistema de equações:

$$
\begin{cases}
2x + y = 5 \\
-3x + 4y = 2
\end{cases}
$$
"""

A = np.array([[2, 1], [-3, 4]])
b = np.array([5, 2])

x = np.linalg.solve(A, b)
print(x)

"""## 3. Números Complexos

### Notação retangular e polar

O Python pode ser utilizado como uma calculadora para números complexos. Para gerar um número complexo em Python, podemos utilizar a notação retangular, tal como:

$$
z = a + jb
$$

Com isso, podemos  calcular a parte real (`np.real()`), parte imaginária (`np.imag()`), magnitude (`np.abs()`) e fase (`np.angle()`) de um número complexo.

Vamos calcular a parte real, imaginária, módulo e fase do número complexo $z = 3 + j4$.
"""

z = 3 + 1j*4

print("Real = ", np.real(z))
print("Imaginaria = ", np.imag(z))

print("Magnitude = ", np.abs(z))
print("Fase (rad) =", np.angle(z))

print("Fase (graus) = ", np.angle(z)*180/np.pi)

"""Da mesma forma, podemos gerar um número complexo utilizando a notação polar:

$$
z = re^{j\theta}
$$

Para isso, vamos utilizar a função `np.exp()` da biblioteca `numpy`.

Vamos calcular a parte real, imaginária, módulo e fase do número complexo $z = 2e^{j\pi/3}$.
"""

z = 2*np.exp(1j*np.pi/3)

print("Magnitude = ", np.abs(z))
print("Fase (rad) = ", np.angle(z))

np.pi/3

print("Real = ", np.real(z))
print("Imaginaria = ", np.imag(z))

"""### Conjugado complexo

A operação de complexo conjungado pode ser realizada através da função `np.conj()`
"""

z = 3 + 1j*4
zconj = np.conj(z)
print(zconj)

z = 2*np.exp(1j*np.pi/3)
print(z)

np.conj(z)

"""### Operações com números complexos

Obviamente, podemos realizar operações de soma, subtração, multiplicação e divisão com números complexos em Python. Para isso utilizaremos os operadores de soma, subtração, multiplicação e divisão convencionais, assim como em outras linguagens de programação.

Então dado os números complexos $z_1 = 3 + j4$ e $z_2 = 5 - j2$, vamos determinar $z_1 + z_2$, $z_1 - z_2$, $z_1z_2$ e $z_1/z_2$.
"""

z1 = 3 + 1j*4
z2 = 5 - 1j*2

zsoma = z1 + z2
print(zsoma)

zsub = z1 - z2
print(zsub)

zmult = z1*z2
print(zmult)

zdiv = z1/z2
print(zdiv)

"""## 4. Polinômios

### Criando polinômios

Para se criar polinômios no Python, podemos utilizar a função `poly1d` da biblioteca `numpy`. Como argumento, passamos os coeficientes do polinômio, sempre iniciando do coeficiente da maior potência.

Por exemplo, vamos criar o polinômio $p(x) = 3x^3 + 2x^2 - 4x + 1$.
"""

import numpy as np

p = np.poly1d([3, 2, -4, 1])
print(p)

"""### Avaliando polinômios

Podemos avaliar o valor do polinômio em um certo valor utilizando substituição direta do polinômio no valor. Vamos calcular o valor do polinômio $p(x)$ anterior no ponto $x = 2$.
"""

y = p(2)
print(y)

y = p(0)
print(y)

y = p(1)
print(y)

"""### Operações com polinômios

Podemos fazer várias operações com polinômios, como soma, subtração, multiplicação e divisão. Vamos supor dois polinômios:

$$
p(x) = 3x^3 + 2x^2 - 4x + 1
$$

$$
q(x) = x^2 - x + 1
$$

Vamos fazer as operações de soma, subtração, multiplicação e divisão entre esses dois polinômios.
"""

p = np.poly1d([3, 2, -4, 1])
q = np.poly1d([1, -1, 1])

print(p)
print(q)

#Soma de polinomios
psum = p + q
print(psum)

#Subtração de polinômios
psub = p - q
print(psub)

#Multiplicacao de polinômios
pmult = p*q
print(pmult)

div, resto = np.polydiv(p, q)
print("Quociente = ")
print(div)
print("Resto = ")
print(resto)

"""### Raízes de polinômios

As raízes de um polinômio podem ser calculadas utilizando a função `roots`. Vamos supor que desejamos calcular as raízes dos polinômios $p(x)$ e $q(x)$ definidos anteriormente.
"""

roots_p = np.roots(p)
print(roots_p)

roots_q = np.roots(q)
print(roots_q)

"""## 5. Plotando gráficos

### Gráficos de funções contínuas bidimensionais

Para plotar gráficos utilizaremos dois vetores: `x` e `y`. O vetor `x` representará o variável independente e variará entre um limite inferior `x_min` e um limite superior `x_max` e conterá `Npoints` valores. Já o vetor `y` será calculado em função do vetor `x`.

Na prática, gerar um gráfico computacionalmente significa calcular a expressão da função para diferentes valores de `x`, sendo que esses valores são tão próximos um do outro que visualmente não notamos diferença da função para esses valores calculados em alguns pontos.

Por exemplo, vamos plotar a função:

$$
y(x) = \cos (20\pi x)
$$

Uma vez que o vetor `x` e o vetor `y` tenham sido gerados, podemos plotar o sinal contínuo utilizando a função `plot` da biblioteca `matplotlib.pyplot`. Podemos definir os rótulos dos eixos `x` e `y` utilizando as funções `xlabel` e `ylabel`, respectivamente. Além disso, é possível usar a função `title` para definir o título do gráfico.
"""

import numpy as np
import matplotlib.pyplot as plt

#Criar o vetor x
x = np.linspace(0, 1, 1000)

#Calcular o vetor y em funcao do vetor x
y = np.cos(20*np.pi*x)

#Plotar o grafico
plt.plot(x, y)
plt.xlabel("x")
plt.ylabel("y(x)")
plt.title("Gráfico de um Cosseno")
plt.grid()
plt.show()

"""### Plotando múltiplas funções

É possível plotar mais de uma função no mesmo gráfico, como apresentado no exemplo abaixo.
"""

#Definindo o vetor x
x = np.linspace(0, 2, 1500)

#Definindo as funcoes
y1 = x**2       #y1(x) = x^2
y2 = x**3       #y2(x) = x^3
y3 = np.sin(x)  #y3(x) = sin(x)

#Criando os graficos
plt.plot(x, y1, label="y = x^2")
plt.plot(x, y2, label="y = x^3")
plt.plot(x, y3, label="y = sin(x)")
plt.xlabel("x")
plt.title("Gráficos sobrepostos")
plt.grid()
plt.legend()
plt.show()

"""### Personalizando um gráfico

Podemos fazer algumas alterações nos gráficos. As possibilidades são imensas, dessa forma, é recomendável que consulte a documentação da `matplotlib` para saber mais detalhes.
"""

#Definindo o vetor x
x = np.linspace(0, 2, 1500)

#Definindo as funcoes
y1 = x**2       #y1(x) = x^2
y2 = x**3       #y2(x) = x^3
y3 = np.sin(x)  #y3(x) = sin(x)

#Criando os graficos
plt.plot(x, y1, 'r--', label="y = x^2")
plt.plot(x, y2, 'g-.', label="y = x^3")
plt.plot(x, y3, 'b', label="y = sin(x)")
plt.xlabel("x")
plt.title("Gráficos sobrepostos")
plt.grid()
plt.legend()
plt.show()

"""### Plotando gráficos lado a lado

O `subplot` é usado para organizar múltiplos gráficos em uma única figura. A sintaxe básica é:

``
plt.subplot(rows, cols, index)
``

* `rows`: Número de linhas de subplots na figura.
* `cols`: Número de colunas de subplots na figura.
* `index`: Índice do subplot atual (começando de 1, da esquerda para a direita, de cima para baixo).
"""

#Definindo o vetor x
x = np.linspace(0, 2, 1500)

#Definindo as funcoes
y1 = x**2       #y1(x) = x^2
y2 = x**3       #y2(x) = x^3
y3 = np.sin(x)  #y3(x) = sin(x)

plt.subplot(1,3,1)
plt.plot(x, y1)
plt.xlabel("x")
plt.ylabel("y1(x)")

plt.subplot(1,3,2)
plt.plot(x, y2, 'r')
plt.xlabel("x")
plt.ylabel("y2(x)")
plt.grid()

plt.subplot(1,3,3)
plt.plot(x, y3)
plt.xlabel("x")
plt.ylabel("y3(x)")

plt.tight_layout()
plt.show()

"""## 6. Derivadas

### Definindo funções simbólicas

Vamos explorar como calcular derivadas em Python utilizando a biblioteca SymPy. O SymPy é uma poderosa biblioteca de álgebra computacional que permite realizar cálculos simbólicos com facilidade.

Para calcular derivadas, primeiro precisamos definir as variáveis simbólicas. Usamos a função `symbols` do SymPy para isso. Após isso, vamos definir uma função para a qual queremos calcular a derivada. Por exemplo, vamos definir a função $f(x) = x^2 + 3x + 2$.
"""



"""### Calculando derivadas

Para calcular a derivada da função $f(x)$ em termos de $x$, usamos a função `diff` do `SymPy`.
"""



"""Vamos, por exemplo, calcular a derivada de $f(x) = \cos x$"""



"""Usando a função `diff`:"""



"""Por fim, vamos calcular a derivada de $f(x) = \cos \left( x^2 + 3x + 2 \right)$"""





"""### Calculando derivadas de ordem superior

Também podemos calcular derivadas de ordem superior especificando a ordem como um terceiro argumento para a função `diff`. Vamos supor que desejamos calcular a derivada segunda da função $f(x) = x^2 + 3x + 2$.
"""



"""### Avaliando a derivada em um ponto específico

Para avaliar a derivada em um ponto específico, usamos a função `subs`.
"""





"""### Plotando gráfico de derivadas

Para visualizar a função original e sua derivada, podemos usar a biblioteca `matplotlib`.
"""

